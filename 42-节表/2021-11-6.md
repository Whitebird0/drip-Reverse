联合体
---

我们想存储一个人的学号和身份证号，而且只要存储一个就可以了.				
				
假如学号需要一个字节，身份证需要四个字节				
				
如果设计成：				
				
            struct Student				
            {				
              char 学号;			

              int 身份证号;			
            }				

因为每次最多用一个成员，那另一个成员的空间永远是浪费的.				


联合体

            union TestUnion	
            {	
              char x;
              int y;
            };	

特点	
		
          1、联合体的成员是共享内存空间的		
          2、联合体的内存空间大小是联合体成员中对内存空间大小要求最大的空间大小		
          3、联合体最多只有一个成员有效		

节表数据结构说明
---

						
            #define IMAGE_SIZEOF_SHORT_NAME              8						

            typedef struct _IMAGE_SECTION_HEADER {						
                BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];						//8个字节 一般情况下是以"\0"结尾的ASCII码字符串来标识的名称，内容可以自定义.
                union {						
                        DWORD   PhysicalAddress;						
                        DWORD   VirtualSize;						
                } Misc;						                                //该节在没有对齐前的真实尺寸,该值可以不准确。
                DWORD   VirtualAddress;						                //节区在内存中的偏移地址。加上ImageBase才是在内存中的真正地址.
                DWORD   SizeOfRawData;						                //节在文件中对齐后的尺寸
                DWORD   PointerToRawData;						        	//节区在文件中的偏移
                DWORD   PointerToRelocations;						
                DWORD   PointerToLinenumbers;						
                WORD    NumberOfRelocations;						
                WORD    NumberOfLinenumbers;						
                DWORD   Characteristics;						         //节的属性  
            } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;						

利用程序打印节表:


                char* fptr = (pFileBuffer + (pDosHeader->e_lfanew) + 4 + IMAGE_SIZEOF_FILE_HEADER + pPEHeader->SizeOfOptionalHeader);
                for (size_t i = 0; i < pPEHeader->NumberOfSections; i++)
                {

                  pSectionHeader = PIMAGE_SECTION_HEADER(fptr);
                  printf("**********************节表%d**********************\n",i+1);
                  printf("Name:%s\n", pSectionHeader->Name);
                  printf("Misc:%X\n", pSectionHeader->Misc);
                  printf("VirtualAddress:%X\n", pSectionHeader->VirtualAddress);
                  printf("SizeOfRawData:%X\n", pSectionHeader->SizeOfRawData);
                  printf("PointerToRawData:%X\n", pSectionHeader->PointerToRawData);
                  printf("PointerToRelocations:%X\n", pSectionHeader->PointerToRelocations);
                  printf("PointerToLinenumbers:%X\n", pSectionHeader->PointerToLinenumbers);
                  printf("NumberOfRelocations:%X\n", pSectionHeader->NumberOfRelocations);
                  printf("NumberOfLinenumbers:%X\n", pSectionHeader->NumberOfLinenumbers);
                  printf("Characteristics:%X\n", pSectionHeader->Characteristics);
                  fptr = fptr + IMAGE_SIZEOF_SECTION_HEADER;
                }

F0A与R0A相互转换
---
			DWORD RvaToFileOffset(PVOID pBuffer, DWORD dwRva) {
			PIMAGE_DOS_HEADER pDosHeader = NULL;
			PIMAGE_NT_HEADERS pNTHeader = NULL;
			PIMAGE_FILE_HEADER pPEHeader = NULL;
			PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL;
			PIMAGE_SECTION_HEADER pSectionHeader = NULL;
			if (!pBuffer)
			{
				printf("(RvaToFileOffset)Can't open file!\n");
				return 0;
			}
			printf("ImageOffset: %#x\n", dwRva);
			pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;
			pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pBuffer + (pDosHeader->e_lfanew));
			pPEHeader = (PIMAGE_FILE_HEADER)((DWORD)pBuffer + (pDosHeader->e_lfanew) + 4);
			pOptionHeader = PIMAGE_OPTIONAL_HEADER32((DWORD)pBuffer + (pDosHeader->e_lfanew) + 4 + IMAGE_SIZEOF_FILE_HEADER);
			pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pBuffer + pPEHeader->SizeOfOptionalHeader);
			char* fptr = (char *)((DWORD)pBuffer + (pDosHeader->e_lfanew) + 4 + IMAGE_SIZEOF_FILE_HEADER + pPEHeader->SizeOfOptionalHeader);
			if (dwRva <= pOptionHeader->SizeOfHeaders)//先判断是否在头部
				return (DWORD)dwRva;
			else {
				for (size_t i = 0; i < pPEHeader->NumberOfSections; i++) {
					//判断 :   文件对齐+文件偏移>file_offset>文件偏移  (即是在文件的哪个节中)
					pSectionHeader = PIMAGE_SECTION_HEADER(fptr);
					if ((dwRva >= pSectionHeader->VirtualAddress) && (dwRva < pSectionHeader->VirtualAddress + pSectionHeader->Misc.VirtualSize))
					{
						return dwRva - pSectionHeader->VirtualAddress + pSectionHeader->PointerToRawData;
					}else {
						fptr = fptr + IMAGE_SIZEOF_SECTION_HEADER;
					}
				}

				}
			}

		DWORD FoaToImageOffset(PVOID pBuffer, DWORD dwFoa) {
			PIMAGE_DOS_HEADER pDosHeader = NULL;
			PIMAGE_NT_HEADERS pNTHeader = NULL;
			PIMAGE_FILE_HEADER pPEHeader = NULL;
			PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL;
			PIMAGE_SECTION_HEADER pSectionHeader = NULL;
			if (!pBuffer)
			{
				printf("(FoaToImageOffset)Can't open file!\n");
				return 0;
			}
			printf("FileOffset: %#x\n", dwFoa);
			pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;
			pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pBuffer + (pDosHeader->e_lfanew));
			pPEHeader = (PIMAGE_FILE_HEADER)((DWORD)pBuffer + (pDosHeader->e_lfanew) + 4);
			pOptionHeader = PIMAGE_OPTIONAL_HEADER32((DWORD)pBuffer + (pDosHeader->e_lfanew) + 4 + IMAGE_SIZEOF_FILE_HEADER);
			pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pBuffer + pPEHeader->SizeOfOptionalHeader);
			char* fptr = (char*)((DWORD)pBuffer + (pDosHeader->e_lfanew) + 4 + IMAGE_SIZEOF_FILE_HEADER + pPEHeader->SizeOfOptionalHeader);

			if (dwFoa <= pOptionHeader->SizeOfHeaders)
				return (DWORD)dwFoa;
			else
			{
				for (size_t i = 0; i < pPEHeader->NumberOfSections; i++) {
					//判断 :   文件对齐+文件偏移>file_offset>文件偏移  (即是在文件的哪个节中)
					pSectionHeader = PIMAGE_SECTION_HEADER(fptr);
					if ((dwFoa >= pSectionHeader->PointerToRawData) && (dwFoa < pSectionHeader->PointerToRawData + pSectionHeader->SizeOfRawData))
				{
					return dwFoa - pSectionHeader->PointerToRawData + pSectionHeader->VirtualAddress;
				}
				else {
						fptr = fptr + IMAGE_SIZEOF_SECTION_HEADER;
				}
				}
			}
		}



		char*  ReadFilea(const char *Filepath ){
			FILE *fptr=NULL;
			fptr = fopen(Filepath,"rb");//打开exe
			if (fptr == NULL) {
				printf("打开失败");
				return NULL;
			}
			int filesize = 0;
			filesize = GetFileszie(fptr);//获取文件大小
			if (filesize==0)
			{
				printf("获取文件大小失败");
				return NULL;
			}
			char* FileBuffer = (char*)malloc(filesize);//申请一段动态空间
			if (FileBuffer==NULL)
			{
				printf("开辟空间失败");
				return NULL;
			}
			size_t n=fread(FileBuffer,  1, filesize, fptr);//将文件内容读到内存中
			if (!n)
			{
				printf("读取数据失败");
				free(FileBuffer);
				FileBuffer = NULL;
				fclose(fptr);
				return NULL;
			}
			fclose(fptr);
			return FileBuffer;
		}



		int GetFileszie(FILE *fptr) {
		//用fseek函数把位置指针移到文件尾,再用ftell函数获得这时位置指针距文件头的字节数,这个字节数就是文件的长度
			int num = 0;
			fseek(fptr, 0, SEEK_END);//把fp文件读写位置指针从SEEK_END开始后移0个字节. 相当于把指针放到了文件尾 
			num = ftell(fptr);//ftell 用于得到文件位置指针当前位置相对于文件首的偏移字节数
			fseek(fptr, 0, SEEK_SET);//使用完毕后，要将文件指针指向文件开始
			return num;
		}

		void test() {
			LPVOID pFileBuffer = NULL;
			size_t pRVA = 0x12345;
			size_t pFOA = 0x5544;
			pFileBuffer = ReadFilea("C:\\Users\\Whitebird\\Desktop\\example\\example\\02\\14\\bin\\notepad.exe");


			DWORD ret_FOA1 = RvaToFileOffset(pFileBuffer, pRVA);
			printf("内存偏移%#x 转换为文件中的偏移: %#x\n", pRVA, ret_FOA1);
			DWORD ret_RVA1 = FoaToImageOffset(pFileBuffer, pFOA);
			printf("文件偏移%#x 转换为内存中的偏移: %#x\n", pFOA, ret_RVA1);
			free(pFileBuffer);

		}
		int main() {

			test();
		}
