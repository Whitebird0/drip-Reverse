程序加载的过程：
---

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ%E6%88%AA%E5%9B%BE20220203205450.png)

**注意**

1.一般情况下，EXE都是可以按照ImageBase的地址进行加载的.因为EXE拥有自己独立的4GB的虚拟内存空间。但DLL不是，DLL是有EXE使用它，才加载到相关EXE的进程空间的.

2.为了提高搜索的速度，模块间地址也是要对齐的 模块地址对齐为10000H，也就是64K

为什么要用重定位表？
---

1.打开一个程序，观察一下全局变量的反汇编

        00401D58 A1 44 CA 42 00       mov         eax,[x (0042ca44)]			
        00401D5D 50                   push        eax			
        00401D5E 68 EC 91 42 00       push        offset string "%d\n" (004291ec)			
        00401D63 E8 28 62 00 00       call        printf (00407f90)			
			
我们发现变量x和%d的地址是写死的，直接写在了硬编码中，这个地址是 ImageBase+RVA。

如果程序在加载的时候没有按照约定的400000 载入到指定的位置

但程序执行的时候，仍然会按照0042ca44和004291ec的地址去使用这个值，这时候就会出现错误

**注意**

1.这就是说，如果程序能够按照预定的ImageBase来加载的话，那么就不需要重定位表。这也是为什么exe很少有重定位表，而DLL大多都有重定位表的原因

2.一旦某个模块没有按照ImageBase进行加载，那么所有类似上面中的地址就都需要修正，否则，引用的地址就是无效的.

3.一个EXE中，需要修正的地方会很多，那我们如何来记录都有哪些地方需要修正呢？这就需要重定位表了。

重定位表的结构分析
---

数据目录项的第6个结构，就是重定位表.

      typedef struct _IMAGE_DATA_DIRECTORY {					
          DWORD   VirtualAddress;					
          DWORD   Size;					
      } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;					

这个地址指向重定位表的地址.

      typedef struct _IMAGE_BASE_RELOCATION {						
          DWORD   VirtualAddress;						
          DWORD   SizeOfBlock;						
      } IMAGE_BASE_RELOCATION;						
      typedef IMAGE_BASE_RELOCATION ，* PIMAGE_BASE_RELOCATION;						

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ%E6%88%AA%E5%9B%BE20220203214110.png)

重定位表不止一个，可能有很多个，SizeOfBlock是每一块的大小

**为什么分成很多块**

        VirtualAddress 4字节  X 			
        SizeOfBlock 4字节		 Y	
        0011101010101010		0011101010101010	
        0011101010101010		0011101010101010	
        我们假如要修改的地址为8012，8023，8034......
        我们把8000放在VirtualAddress中，12，23，34放到后面块中，这样可以节省空间
        
**解析说明：**

1、通过IMAGE_DATA_DIRECTORY结构的VirtualAddress属性，找到第一个IMAGE_BASE_RELOCATION

2、判断一共有几块数据：最后一个结构的VirtualAddress与SizeOfBlock都为0

3、具体项 宽度：2字节

 内存中的页大小是1000H 也就是说2的12次方 就可以表示一个页内所有的偏移地址 。具体项的宽度是16字节，高四位代表类型（值为3代表需要修改的数据，值为0代表的是用于数据对齐的数据，可以不用修改）

4、VirtualAddress 宽度：4字节

当前这一个块的数据，每一个低12位的值+VirtualAddress 才是真正需要修复的数据的RVA

5、SizeOfBlock 宽度：4字节

当前块的总大小，具体项的数量 = (SizeOfBlock - 8)/2 

			
